#!/bin/sh

in="$1"
out="$2"
proto_h="$3"

# should be picked from $(srctree)/Makefile
USERINCLUDE="-Iinclude -Iinclude/generated/ -Iarch/lkl/include/generated -Iarch/lkl/include/generated/uapi -Iarch/lkl/include"

# obtain supported system calls from ${in} (lkl/include/uapi/asm/unistd.h)
SYSCALL_NR_LIST=$(grep "#define __NR" ${in} | awk '{print $2}')

NR_syscall_max=0

mkdir -p $(dirname ${proto_h})

cat <<EOF > ${proto_h}
/*
 * System call prototypes for rump.
 * DO NOT EDIT-- this file is automatically generated.
 */

struct pollfd;
struct epoll_event;
struct msghdr;
struct mmsghdr;
struct user_msghdr;
struct iovec;
struct sockaddr;
struct timeval;
struct timespec;
struct stat64;
struct statfs64;
struct utimbuf;

#ifndef umode_t
typedef unsigned short		umode_t;
#endif /* umode_t */

#ifndef size_t
typedef __kernel_size_t		size_t;
#endif

#ifndef __dead
#define __dead __attribute__((__noreturn__))
#endif

#ifndef __printflike
#ifdef __GNUC__
#define __printflike(a,b) __attribute__((__format__ (__printf__,a,b)))
#else
#define __printflike(a,b)
#endif
#endif

#ifndef loff_t
typedef long long      loff_t;
#endif /* loff_t */
typedef int            clockid_t;
typedef unsigned long          u_long;
typedef unsigned int           u_int;
#define RUMP_REGISTER_T long
typedef RUMP_REGISTER_T register_t;
typedef int            pid_t;

#ifndef uid32_t
typedef unsigned int	uid32_t;
typedef unsigned int	gid32_t;
#endif

EOF



cat <<EOF > ${out}
/*
 * System call vector and marshalling for LKL.
 *
 * DO NOT EDIT-- this file is automatically generated.
 */


#ifdef RUMP_CLIENT
#include <rump/rumpuser_port.h>
#endif /* RUMP_CLIENT */

#include <asm/unistd.h>
#include <linux/rump_syscalls.h>


#ifdef RUMP_CLIENT
#include <errno.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <rump/rumpclient.h>

#define rsys_syscall(num, data, dlen, retval)	\
    rumpclient_syscall(num, data, dlen, retval)
#define rsys_seterrno(error) errno = error

#else /* !RUMP_CLIENT */

#include <linux/compiler.h>
#include <linux/types.h>
#include <linux/string.h>
#include <asm-generic/errno.h>

#include <rump/rump.h>
#include <rump/rumpuser.h>
int rump_syscall(int num, void *data, size_t dlen, register_t *retval);
#define rsys_syscall(num, data, dlen, retval)	\
    rump_syscall(num, data, dlen, retval)

#define rsys_seterrno(error) rumpuser_seterrno(error)

#endif

EOF

declare -A hash_

# XXX: obtain supported system calls from ${in} (uapi/asm/unistd.h/?)
grep '#define __NR_' "$in"  | (
    while read def nr num; do
	name=$(echo $nr | sed "s/__NR_//")
	hash_[$name]=$num
    done
)

set -f
cpp -P ${USERINCLUDE} "$in" 2> /dev/null | \
    grep -E "^static inline long lkl_sys" | sed "s/{.*//" | (
    while read mod inline ret func; do
	#echo $func
	# 1) count the number of argument
	func_l=/$func/
	IFS=','
	set -- $func_l
	count=0
	if [ $(echo $func | sed "s/.*(//") != "void)" ] ; then
	    count=`expr $(($#-1)) + 1`
	fi
	#echo "argc = $count"
	IFS=' '

	# 2) pull the system call name
	funcname=$(echo $func | sed "s/(.*//" | sed "s/lkl_sys_//")

	# 3) pull arg name template
	args=$(echo $func | sed "s/.*(/(/" | sed "s/__lkl__kernel_//g" | sed "s/lkl_//g" | sed "s/[()]//g")
	OIFS="$IFS"; IFS=','
	arg=($args); IFS="$OIFS"

	# 4) give a template based on funcname, args
	cat <<EOF

${ret} rump___sysimpl_${funcname}(${args})
{
	int ret;
	long params[6];

	memset(params, 0, sizeof(params));
EOF

	for i in {1..6} ; do
	    if [ $i -gt ${count} ] ; then
		break
	    fi
	    param=$(echo ${arg[$((i-1))]} | sed "s/.* \(.*\)$/\1/")
	    cat <<EOF
	params[$((i-1))] = (long)${param};
EOF
	done
	IFS=' '

	cat <<EOF

	ret = lkl_syscall(__NR_${funcname}, params);
	/* errno handling */
	if (ret < 0) {
		rsys_seterrno(-ret);
		ret = -1;
	}
	return ret;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(${name},rump___sysimpl_${funcname});
__weak_alias(_${name},rump___sysimpl_${funcname});
__strong_alias(_sys_${name},rump___sysimpl_${funcname});
#endif /* RUMP_KERNEL_IS_LIBC */

EOF
	echo "${ret} rump___sysimpl_${funcname}(${args});" >> "${proto_h}"
	echo "${ret} rump_sys_${funcname}(${args}) __asm(\"rump___sysimpl_${funcname}\");" >> "${proto_h}"

    done
) >> "$out"

# exception for __NR_reboot
cat <<EOF >> ${out}

long rump___sysimpl_reboot(int magic1, int magic2, unsigned int cmd, void * arg)
{
	lkl_sys_halt();

	/* should not return */
	return 0;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(,rump___sysimpl_reboot);
__weak_alias(_,rump___sysimpl_reboot);
__strong_alias(_sys_,rump___sysimpl_reboot);
#endif /* RUMP_KERNEL_IS_LIBC */
EOF

echo "long rump___sysimpl_reboot(int magic1, int magic2, unsigned int cmd, void * arg);" >> "${proto_h}"
echo "long rump_sys_reboot(int magic1, int magic2, unsigned int cmd, void * arg) __asm(\"rump___sysimpl_reboot\");" >> "${proto_h}"

exit

cat <<EOF >> ${out}

/* For hijack.c compatibility of NetBSD */
__weak_alias(rump___sysimpl_socket30,rump___sysimpl_socket);
__weak_alias(rump___sysimpl_pwrite,rump___sysimpl_pwrite64);
__weak_alias(rump___sysimpl_pread,rump___sysimpl_pread64);
__weak_alias(rump___sysimpl_utimes50,rump___sysimpl_utimes);
__weak_alias(rump___sysimpl_nanosleep50,rump___sysimpl_nanosleep);

EOF
